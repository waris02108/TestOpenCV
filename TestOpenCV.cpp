// TestOpenCV.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
//opencv
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video/background_segm.hpp>
#include <opencv2/video.hpp>
#include <opencv2/features2d/features2d.hpp>


#include "opencv2/objdetect.hpp"

//C
#include <stdio.h>

//C++
#include <iostream>
#include <sstream>

using namespace cv;
using namespace std;
// Global variables
Mat frame; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG;
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
Mat kernel = getStructuringElement(MORPH_RECT, Size(400, 400), Point(3, 3));
Mat resize_blur_Img;
Mat ContourImg;
Mat binaryImg;
int keyboard; //input from keyboard
int thresh = 100;
void processVideo(char* videoFilename);
void processImages(char* firstFrameFilename);
void testContour(char* imgFilename);
void testBlobDetector(char* imgFilename);
void testBlobDetector(Mat mask);
void drawVirtualLine();
RNG rng(12345);
cv::Mat element = getStructuringElement(MORPH_RECT, Size(9, 9), Point(3, 3));

int main(int argc, char* argv[])
{
	
//	//create GUI windows
	namedWindow("Frame",WINDOW_AUTOSIZE);
	namedWindow("FG Mask MOG 2",WINDOW_AUTOSIZE);
	namedWindow("keypoints", WINDOW_AUTOSIZE);
	//create Background Subtractor objects
	pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach create MOG2
	
	
	//testContour("example.jpg");
	//testBlobDetector("ex2.png");
	//detectCascade();
	processVideo("MVI_1928.MOV");
	//destroy GUI windows
	destroyAllWindows();
	return EXIT_SUCCESS;
}
void processVideo(char* videoFilename) {
	//create the capture object
	VideoCapture capture(videoFilename);
	if (!capture.isOpened()) {
		//error in opening the video input
		cerr << "Unable to open video file: " << videoFilename << endl;
		exit(EXIT_FAILURE);
	}

	

	//read input data. ESC or 'q' for quitting
	int count = 0;
	while ((char)keyboard != 'q' && (char)keyboard != 27) {
		//read the current frame
		if (!capture.read(frame)) {
			cerr << "Unable to read next frame." << endl;
			cerr << "Exiting..." << endl;
			exit(EXIT_FAILURE);
		}
		//cout << "hey";

		resize(frame, resize_blur_Img, Size(frame.size().width/2, frame.size().height/2));
		//Blur  
		blur(resize_blur_Img, resize_blur_Img, Size(3, 3));
		imshow("Frame", resize_blur_Img);
		//update the background model
		pMOG2->apply(resize_blur_Img, fgMaskMOG2);
		//pMOG->apply(resize_blur_Img, fgMaskMOG2, -0.5);//,-0.5);  
													 


		threshold(fgMaskMOG2, binaryImg, 128, 255, CV_THRESH_BINARY);
		morphologyEx(binaryImg, ContourImg, MORPH_CLOSE, element);
		//dilate(binaryImg, binaryImg, element);


		vector<vector<Point> > contours;
		//keypoints.clear();
		//detector->detect(binaryImg, keypoints);
		Mat im_with_keypoints;
		//drawKeypoints(resize_blur_Img, keypoints, im_with_keypoints, Scalar(0, 0, 255), DrawMatchesFlags::DRAW_RICH_KEYPOINTS);
		cv::findContours(ContourImg, contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE);
		// Show blobs
		//imshow("keypoints", im_with_keypoints);
		//Mat temp;
		vector< vector< Point> >::iterator itc = contours.begin();
		
		line(resize_blur_Img, Point(200, 280), Point(500, 280), CV_RGB(200, 200, 0), 2);
		for (int i = 0; i < contours.size(); i++) {
			Rect mr = boundingRect(contours[i]);
			double carArea = contourArea(contours[i]);
			//cout << "Area" << carArea;
			if (carArea <= 100) {
				continue;
			}
			CvMoments moment = moments(contours[i]);
			int centerx = (int)(moment.m10 / moment.m00);
			int centery = (int)(moment.m01 / moment.m00);
			if (centery == 280  && centerx >=200 && centerx<=500) {

				if (i != 0) {
					CvMoments preMoment = moments(contours[i - 1]);
					int previousy = (int)(preMoment.m01 / preMoment.m00);
					
					if (centery = 280) {
						count++;
						cout << "No of Cars:" << count << "\n";
					}
					/*if (previousy < 280 && centery >= 280) {
						count++;
						
					}*/
				}
				
			}
			Point2f centroid = Point2f(centerx, centery);
			circle(resize_blur_Img,centroid,4,CV_RGB(0,255,0),-1,8,0);
			rectangle(resize_blur_Img, mr, CV_RGB(255, 0, 0));
		}
		//while (itc != contours.end()) {

		//	//temp = itc;
		//	//if (contourArea() < 200){ continue; }
		//	//if (contourArea(itc))
		//	//Create bounding rect of object  
		//	//rect draw on origin image 
		//	
		//	Rect mr = boundingRect(Mat(*itc));
		//	
		//	cout << "Area" << contourArea(Mat(*itc));
		//	if (contourArea(Mat(*itc)) <= 100) {
		//		++itc;
		//		continue;
		//	}
		//	CvMoments moment; 
		//	cvMoments(,moment);
		//	Point centroid;
		//	rectangle(resize_blur_Img, mr, CV_RGB(255, 0, 0));
		//	++itc;
		//}

		imshow("Frame", resize_blur_Img);
		imshow("FG Mask MOG 2", fgMaskMOG2);
		imshow("keypoints", binaryImg);
		//	keypoints.clear();
		//get the input from the keyboard
		keyboard = waitKey(30);
	}

	//delete capture object
	capture.release();
}
void drawVirtualLine() {

}





